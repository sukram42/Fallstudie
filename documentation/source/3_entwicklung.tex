\chapter{Entwicklung}

\section{Java Backend}

Im folgenden wird der Aufbau und die Funktionalität des Java Backends und der einzelnen Klassen dargestellt, auf Grund von Platzmangel wird hier nur auf die wichtigsten Funktionalitäten und Methoden eingegangen.

Die Klasse \enquote{Game} implementiert die Spiellogik und das Echtzeit-Konzept. Hier werden Aktionen, die alle Spieler beziehungsweise Unternehmen betreffen durchgeführt sowie die Unternehmen, beispielsweise für die Festlegung des Gewinners einer Ausschreibung, verglichen.

Die Hauptfunktionalität des Unternehmensplanspiels ist im Package \enquote{Unternehmung} umgesetzt, das, strukturell gesehen, \enquote{unter} der Klasse \enquote{Game} liegt. Hier sind neben der Klasse \enquote{Unternehmen} die einzelnen Abteilungen eines solchen mit ihren verschiedenen Möglichkeiten, die dem Spieler hier zur Verfügung stehen, implementiert (Package \enquote{Abteilungen}) sowie das Kennzahlenwesen eines Unternehmens (Package \enquote{Kennzahlen}). Darüber hinaus befinden sich in diesem Package die notwendigen Java-Klassen, durch deren Objekte ein objektorientierter Programmieransatz realisiert wird. Einige Methoden werfen Exceptions, die im Package \enquote{Exceptions} abgelegt sind.


\subsection{Die Klasse \enquote{Game}} \textnormal{\textsf{\small{Luca Dommes}}}}

In der Klasse Game ist die Logik und Mechanik des Untenehmensplanspiels implementiert, sie steht, strukturell gesehen, über allen anderen Klassen.

Zunächst einmal ist zu erwähnen, dass es sich hierbei um eine Spezialisierung der Java-Klasse \enquote{TimerTask}\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html} handelt. Dies dient der Umsetzung des Echtzeit-Ansatzes des Spiels. So wird im Konstruktor der Game-Klasse ein Timer-Objekt erstellt, das mit einem Intervall von 16 Minuten initialisiert wird. 16 Minuten stellen also einen Tag in Spielzeit dar. Im statischen Klassenattribut \enquote{gameCalendar} wird die Spielzeit als Calendar-Objekt\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html} dargestellt, das bei jedem Timer Intervall einen Tag hochgezählt wird. Wenn 16 Minuten also ein Spieltag sind vergehen pro Stunde 3,75 Spieltage und dementsprechend an einem Tag (3,75 * 24 =) 90 Spieltage, sprich ein Quartal. Daraus folgt, dass ein Geschäftsjahr 4 (Echtzeit-)Tage dauert.

Die Klasse Game besteht hauptsächlich aus statischen Methoden, um die Zugriffe auf die Klasse zu erleichtern. Wie im Folgenden häufig beschrieben wird oftmals aus den verschiedensten Klassen auf die Klasse Game zugegriffen, unter Anderem um auf das Calendar-Objekt zuzugreifen und somit das aktuelle Datum abzugreifen. Hierfür müsste jeder Klasse das Game-Objekt mitgegeben werden. Durch die statischen Methoden wird dies überflüssig.

In der statischen ArrayList\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html} \enquote{companies} sind die Unternehmens-Objekte der einzelnen Mitspieler abgelegt. In einer zweiten ArrayList \enquote{companiesArchiv} werden Unternehmen im Falle des Bankrott abgelegt. Darüber hinaus gibt es noch eine ArrayList \enquote{\textbf{ausschreibungen}}, was es mit dieser Liste auf sich hat wird in \ref{Vertrieb} dargestellt.

In der statischen Map \enquote{highscores} werden die Spielstände gespeichert. Hier wird, entweder im Falle des Spielendes, also zehn Jahre nach Gründung eines Unternehmens, oder beim Bankrott eines Unternehmens, der Eigenkapital-Endbestand sowie der Unternehmensname abgespeichert. An das Frontend wird diese Liste über die Methode \enquote{getHighscoresAsTreeMap()} als TreeMap\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html} absteigend sortiert ausgeliefert.

Bei jedem Timer Count, sprich alle 16 Minuten, wird die Methode run() ausgeführt. In dieser Methode wird das Datum (also das Calendar-Objekt) um einen Tag hoch gezählt (updateCounter()). Anschließend wird über die Unternehmens-Liste iteriert und die update()-Methode aller Unternehmen aufgerufen (hierzu mehr in \ref{Unternehmen}). Basierend hierauf werden die Makrtanteile neu berechnet (siehe folgender Absatz). Zu letzt wird, nur für den Fall, dass der aktuelle Tag der letzte eines Geschäftsjahres, also der 31. Dezember, ist, die Methode updateYearly() aufgerufen, die eine Aufstellung des Jahresabschlusses auslöst (mehr in \ref{Unternehmen}).

Die Methoden updateMarktanteil(), zur Berechnung der neuen Marktanteile, und die Methode updateAusschreibungen() zur Erteilung eines Zuschlages, dem Löschen alter sowie Generierung neuer Ausschreibungen nehmen Bezug auf die Klassen \enquote{Kennzahlensammlung} (siehe \ref{Kennzahlen}) und \enquote{Vertrieb} (siehe \ref{Vertrieb}) und werden in den entsprechenden Kapiteln näher erklärt. Der Grund, aus dem sich die Methoden in der Game-Klasse befinden liegt in der Tatsache, dass hierfür übergreifend auf alle Spielstände, sprich Unternehmen, zugegriffen werden muss beziehungsweise übergreifende Vergleiche stattfinden müssen.


\subsection{Das Package \enquote{Unternehmung}}

Das Package \enquote{Unternehmung} beinhaltet alle Klassen, die für die Abbildung eines Unternehmens und seiner Funktionen notwendig ist. Es beinhaltet zwei weitere Packages, nämlich \enquote{Kennzahlen}, hier sind die notwendigen Java-Klassen zum Kennzahlen-Management (mehr in \ref{Kennzahlen}) untergebracht, und \enquote{Abteilungen}, in welchem entsprechend die einzelnen Abteilungs-Klassen eines Unternehmens liegen. Darüber hinaus befindet sich im Package \enquote{Unternehmung} die Unternehmens-Klasse selbst (siehe \ref{Unternehmen}) sowie (im Package \enquote{Objekte}) sämtliche Klassen, deren Objekte für die objektorientierte Programmierung eines Unternehmensplanspiels nützlich sind. All dies wird im nachfolgenden Schritt für Schritt erklärt.

\subsubsection{Die Klasse \enquote{Unternehmen}} \textnormal{\textsf{\small{Luca Dommes}}}}
\label{Unternehmen}

Ein Objekt der Klasse \enquote{Unternehmen} repräsentiert ein Unternehmen und somit praktisch auch einen Spieler des Unternehmensplanspiels. Bei der Neuregistrierung eines neuen Spielers wird also ein neues Unternehmen gegründet, sprich ein Objekt der Klasse Unternehmen erzeugt. Dem Konstruktor der Klasse wird der vom Nutzer gewählte Unternehmensname sowie sein Passwort mitgegeben, außerdem das Eigenkapital, sprich Gründungskapital, das allerdings vorgegeben ist. Der Konstruktor kopiert sich das aktuelle Kalenderdatum und hinterlegt dieses als \enquote{gruendungsDatum}, auf Grund dessen gleichzeitig ein Datum für das Spielende (\enquote{gameEnd}) berechnet wird. Dieses ist 10 Jahre nach dem Gründungsdatum. Darüber hinaus richtet der Konstruktor die Kennzahlensammlung (vgl. \ref{Kennzahlen}) ein und führt die Methode initDepartments() aus, die in der Map \enquote{abteilungen} die notwendigen neuen Abteilungs-Objekte des Unternehmens erstellt. Somit ist der erste Schritt getan, das Unternehmen steht.

Neben dem Konstruktor und der Methode zum Initialisieren der Abteilungs-Map beziehungsweise dem Erstellen der neuen Abteilungen gibt es noch die Methode update(), die, aufgerufen bei jedem Timer Count, über die Map der Abteilungen iteriert und für jede Abteilung die update()-Methode (hierzu genaueres in \ref{Abteilungen}) aufruft sowie gegebenenfalls die updateYearly()-Methode, die beim letzten Timer Count des Jahres aufgerufen wird und den Jahresabschluss (siehe \ref{Kennzahlen}) veranlasst.

Die Klasse \enquote{Mitarbeiter} repräsentiert einen Mitarbeiter des unternehmens und hat die Attribute \enquote{name}, \enquote{vorname}, \enquote{imagelink} (für das Bild, vgl. \ref{HR}), \enquote{department}, also die Abteilung in der er arbeitet, \enquote{gender} für das Geschlecht, \enquote{gehalt} und \enquote{prodLeistung}, was die mögliche monatliche Produktionsmenge eines einzelnen Mitarbeiters (der in der Abteilung Produktion eingestellt ist) wieder spiegelt.


\subsubsection{Umsetzung des Kennzahlenkonzepts} \textnormal{\textsf{\small{Luca Dommes}}}}
\label{Kennzahlen}

Um unternehmensinterne Abläufe möglichst genau abzubilden wird auch auf eine realitätsnahe Implementierung der Buchhaltung von Unternehmen Wert gelegt.

\subsubsubsection{Bilanz und Gewinn- und Verlustrechnung} \textnormal{\textsf{\small{Luca Dommes}}}}
\label{Bilanz und GuV}

Eine wichtige Klasse dieser Buchführung ist die Klasse \enquote{Bilanz}. Hier werden Aktiva wie Maschinen, Gebäude, Fertige Erzeugnisse und liquide Mittel sowie Passiva wie Eigenkapital und Fremdkapital, als float-Werte festgehalten und bei den zur Verfügung stehenden Aktionen entsprechend dynamisch angepasst. Für diese dynamische Anpassung wird von Methoden für Aktionen bei denen Zahlungen fließen, etwa der Kauf einer Maschine, über Methoden wie liquiditaetAnpassen() die entsprechenden Werte verändert. Diese Methode wird allerdings auch von Methoden aufgerufen, die zum Beispiel laufende monatlich Kosten \enquote{abrechnen} möchten. Ist hierbei die Liquidität nicht ausreichend kommt es an dieser Stelle zum Wurf einer BankruptException, was für das Unternehmen den Bankrott und somit für den Spieler das Spielende bedeutet.

Darüber hinaus gibt es eine boolesche Methode \enquote{liquiditaetAusreichend()}, die zum Beispiel im eben genannten Fall des Kaufs einer Maschine prüft, ob die liquiden Mittel für diese Aktion ausreichend sind und entsprechend, falls dies der Fall ist, true zurück gibt oder alternativ ein \enquote{ZuWenigCashException} wirft, wodurch am Frontend eine passende Nachricht ausgegeben wird. Als Bilanzsumme werden die beiden Werte \enquote{summeAktiva} und \enquote{summePassiva} herangezogen, die unterjährig entsprechend unausgeglichen sind, jedoch nach dem Jahresabschluss (siehe folgender Absatz) einander gleichen.

Neben der Bilanz ist für die Buchhaltung die Gewinn- und Verlustrechnung, kurz GuV, ebenso wichtig. Hierfür existiert eine weitere Java-Klasse. Hier werden Aufwendungen für Rohstoffe, Werbung, Gehälter, Energie, Soziale Leistungen, Zinsen, Fremdinstandhaltung und Schadensersatz auf der einen sowie Umsatzerlöse auf der anderen Seite dokumentiert. Für die dynamische Anpassung der relevanten Werte wird bei jedem Timer Count durch die update()-Methode der Klasse \enquote{Kennzahlensammlung} zum Einen die Methode \enquote{importAufwandUndErlös()} aufgerufen, die die entsprechenden Aufwendungen und Erlöse um die täglich (also pro Timer Count) konsumierten beziehungsweise umgesetzten Werte der Einzelnen Abteilungen erhöht, und zum Anderen die Methode \enquote{getTaeglicheLiquiditaetsveraenderung()}, die wiederum von der Bilanz-Klasse genutzt wird, um die täglichen Ein- und Auszahlungen auch im Bilanzposten \enquote{liquide Mittel} (über liquiditaetAnpassen()) zu erfassen.
Um dem Spieler einen Überblick über die Entwicklung seiner Ein- und Ausgaben zu ermöglichen werden die monatlichen Aufwendungen und Erlöse in den float-Werten \enquote{aufwendungenArchiv} und \enquote{erloeseArchiv} kumuliert und schließlich in der LinkedList\footnote{https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html} \enquote{archiv} über die am Monatsende aufgerufene Methode \enquote{archivieren()} festgehalten. Hierzu wird in archivieren() ein neues GuV-Objekt mit einem Spezialkonstruktor, der die Werte aufwendungenArchiv und erloeseArchiv kopiert, erstellt, das anschließend, versehen mit dem aktuellen Datum, in zuvor genannter LinkedList abgelegt wird. Die Attribute aufwendungenArchiv und erloeseArchiv der \enquote{Unternehmens-GuV} werden wieder entsprechend zurück gesetzt, um die Werte des neuen Monats zu sammeln.

Über die updateYearly()-Methode der Unternehmens-Klasse wird am Jahresende die GuV-Methode \enquote{jahresAbschluss()} aufgerufen. Diese berechnet aus allen Aufwendungen und Erlösen den \enquote{jahresUeberschuss}, in Höhe dessen anschließend das Eigenkapital in der Bilanz (siehe \enquote{eigenkapitalAnpassen()}) angepasst wird, sodass die Bilanz wieder ausgeglichen ist. Die Werte der Aufwendungen und Erlöse werden wieder auf null gesetzt, die nächste Periode kann beginnen.

\subsubsubsection{Weitere Kennzahlen und die Kennzahlensammlung} \textnormal{\textsf{\small{Luca Dommes}}}}

Mit eine der wichtigsten Klassen des Java Backends ist die Klasse \enquote{Kennzahlensammlung}. Hier laufen, wie der Name bereits zu vermuten lässt, sämtliche Kennzahlen des Unternehmens zusammen. Hier können also zentralisiert alle Berechnungen oder Aktualisierungen der Kennzahlen durchgeführt werden. Einige Abteilungs-Klassen greifen auf die Kennzahlensammlung zu, etwa um anhand einer oder mehrerer bestimmter Kennzahlen Entscheidungen zu treffen oder aber selbige zu verändern. Aus diesem Grund wird das Objekt der Kennzahlensammlung eines Unternehmens auch so gut wie jeder weiteren Klasse, in der Regel im Konstruktor, weiter gegeben, sodass die jeweilige Klasse damit \enquote{arbeiten} kann.

Dem Konstruktor der Kennzahlensammlung wird das Unternehmen mitgegeben. Dieses wird weitergegeben an die GuV sowie an die Bilanz, die zwei weitere Klassenattribute darstellen, die im Konstruktor erstellt werden und somit die Buchhaltung des Unternehmens darstellen. Darüber hinaus gibt es ein Attribut \enquote{Marktanteil} für den absoluten mengenmäßigen Marktanteil eines jeden Unternehmens und eine Map \enquote{weicheKennzahlen}, die weitere Kennzahlen enthält auf die nachfolgend eingegangen wird. Das Attribut \enquote{maxNeueMitarbeiter} ist die Anzahl neuer Mitarbeiter, die maximal eingestellt werden können, hierzu jedoch mehr in \ref{HR}.

Bei den sogenannten weichen Kennzahlen handelt es sich um nicht-monetäre Kennzahlen. Diese sind Mitarbeiterzufriedenheit, Kundenzufriedenheit, Image, Bekanntheitsgrad und Verkaufswahrscheinlichkeit. Jede dieser Kennzahlen ist als Subklasse der Superklasse \enquote{Kennzahl} implementiert. Ein Objekt der Klasse Kennzahl besteht aus Basiswert (\enquote{basiswert}), einem Modifier (\enquote{modifier}) sowie einem Endwert (\enquote{wert}). Der \enquote{wert} setzt sich zunächst aus Basiswert und Modifier zusammen. Über die Methode \enquote{getWert()} wird der Endwert zurück gegeben, berechnet mit einem Tangens Hyperbolicus, der sich der eins nur nähert, sie jedoch nie trifft beziehungsweise überschreitet, schließlich können und sollen die hier definierten Kennzahlen nicht mehr als 100 Prozent ergeben. Dass der Wert, wenn er bereits sehr hoch ist (80\% +) langsamer steigt ist ein weiterer gewünschter Nebeneffekt, da es zum Beispiel schwerer sein soll die Mitarbeiterzufriedenheit von 80 auf 90 Prozent zu steigern, als von zehn auf 20 Prozent. Des Weiteren ist die Idee dahinter, dass der Basiswert abhängig von bestimmten Zahlen des Unternehmens ist und durch den Modifier modifiziert wird. Am Beispiel der Mitarbeiterzufriedenheit bedeutet dies, dass sich der Basiswert aus dem durschschnittlichen Gehalt geteilt durch einen festgelegten Wert berechnet, während der Modifier auf die Höhe insofern Einfluss nimmt, als dass er einerseits beispielsweise durch die Auszahlung betrieblicher Sonderzahlungen hoch gesetzt wird, andererseits allerdings auch wieder mit der Zeit, also jeden Timer Count um einen gewissen Wert, wieder sinkt. Dieses Prinzip gilt in gleicher Art und Weise auch für die Kundenzufriedenheit und den Bekanntheitsgrad. Der Basiswert des Images berechnet sich aus der Mitarbeiter- und Kundenzufriedenheit und die Verkaufswahrscheinlichkeit (siehe \ref{Vertrieb}), die für eine hohe Vertragsabschlussquote entscheidend ist, setzt sich wiederum zusammen aus Image und Bekanntheitsgrad.

Die Marktanteile der Unternehmen werden täglich, also bei jedem Timer Count, neu berechnet. Dies geschieht über die Methode updateMarktanteile() in der Game-Klasse, da hierzu auf die Absatzzahlen aller Unternehmen zugegriffen werden muss. Hier wird zunächst die Methode getGesamtabsatz() aufgerufen, die über die Unternehmens-Liste iteriert und für jedes Unternehmen die Anzahl der im vergangen Monat abgesetzten Produkte abfragt (diese Zahlen werden aus der Klasse beziehungsweise Abteilung \enquote{Vertrieb} gewonnen (siehe \ref{Vertrieb})) und die Summe dieser, also den gesamten Absatz des Marktes, zurück gibt. Anschließend iteriert die updateMarktanteile()-Methode erneut über die Unternehmen, setzt die abgesetzte Menge eines jeden Unternehmens ins Verhältnis zum soeben ermittelten Gesamtabsatz und setzt die somit gewonnene Kennzahl des absoluten mengenmäßigen Marktanteils in der Klasse Kennzahlensammlung (siehe \ref{Kennzahlen}).

Die update()-Methode dieser Klasse, die bei jedem Timer Count aufgerufen wird, ruft wiederum die Methode \enquote{kennzahlenRuntersetzen()} auf, die den Modifier aller weichen Kennzahlen etwas herab setzt, sofern dieser nicht schon bei null liegt. Auch dies spiegelt die Realität des Wettbewerbs wieder, in dem es sich kein Unternehmen leisten kann sich \enquote{auszuruhen}. Des Weiteren ruft die update()-Methode die Methode \enquote{berechnen()} auf, die über alle weichen Kennzahlen iteriert und eine Neuberechnung veranlasst. Anschließend wird die Liquidität der Bilanz durch die aus der GuV gewonnen Liquiditätsveränderungen angepasst (vgl. \ref{Bilanz und GuV}).

Ähnlich wie es in der GuV umgesetzt ist werden gewisse Daten auch hier archiviert, allerdings nicht monatlich sondern jährlich. Hierbei handelt es sich um den Jahresabschluss, sprich die GuV zum Jahresende sowie die Schlussbilanz. Hierfür wird die archivieren()-Methode der Kennzahlensammlung von der updateYearly()-Methode der Unternehmens-Klasse aufgerufen. Die archivieren()-Methode erstellt, ähnlich wie es in der GuV der Fall ist, ein neues Kennzahlensammlungs-Objekt anhand eines kopierenden Konstruktors, der die gesamte Bilanz sowie GuV kopiert. Dieses Objekt wird, kombiniert mit dem Datum, in der Map \enquote{archiv} abgelegt.

\subsubsection{Die einzelnen Abteilungen und ihre Funktionen}
\label{Abteilungen}

Die einzelnen Abteilungen sind das, was ein Unternehmen ausmacht. Das Grundgerüst einer Abteilung ist durch die Klasse \enquote{Abteilung} definiert, die jeweils für jede einzelne Abteilung im Package \enquote{Abteilungen} spezialisiert wird. Die Superklasse \enquote{Abteilung} hat als wichtigste Attribute einen Namen als String, eine ArrayList mit Mitarbeiter, die der jeweiligen Abteilung zugeordnet sind, sowie einen float-Wert \enquote{aktKosten}, der die aktuellen laufenden Kosten der Abteilung widerspiegelt. Diese Kosten werden je nach Abteilung individuell gesetzt, über die bei Timer Counts durch die jeweilige update()-Methode aufgerufenen Methoden \enquote{getKosten()} und \enquote{getMitarbeiterKosten()} werden die täglich anfallenden Kosten sowie monatlich anfallenden Gehälter an die GuV und die Bilanz zur \enquote{Verbuchung} weiter gegeben.

In der Abteilungs-Klasse ist auch die Methode \enquote{addMitarbeiter()} implementiert. Die semantische Zugehörigkeit dieser Methode liegt eigentlich in der Abteilung \enquote{Human Resources}, die Methode ist jedoch hier implementiert, sodass der neu eingestellte Mitarbeiter direkt einer entsprechenden Abteilung zugeordnet ist und in der ArrayList \enquote{mitarbeiter} der Abteilung aufgenommen wird. Am Frontend wird die Funktion, Mitarbeiter einzustellen, dementsprechend in der Abteilung \enquote{Human Resources} angezeigt. Der genaue Vorgang des Einstellens eines Mitarbeiters wird im folgenden Kapitel \ref{HR} näher dargelegt.

\subsubsubsection{Human Resources} \textnormal{\textsf{\small{Luca Dommes}}}}
\label{HR}

In der Abteilung \enquote{Human Resources}, kurz HR, ist die weitere Verwaltung der Mitarbeiter implementiert. So hat man am Frontend hier entsprechend die Möglichkeit, wie bereits erwähnt, Mitarbeiter einzustellen, aber auch diesen zu kündigen beziehungsweise sich die Liste der Mitarbeiter anzusehen.

Zum Einstellen eines neuen Mitarbeiters wird (in der Klasse \enquote{Abteilung}) die Methode \enquote{addMitarbeiter()} aufgerufen. Hier kommt nun auch der Integer-Wert \enquote{maxNeueMitarbeiter} in der Kennzahlensammlung (vgl. \ref{Kennzahlen}) zum Einsatz. Es ist nämlich nur möglich Mitarbeiter in anderen Abteilungen als Human Resources einzustellen, wenn genügend Mitarbeiter in Human Resources, People Manager also, eingestellt sind. Der Startwert von \enquote{maxNeueMitarbeiter} liegt bei 10. Das bedeutet, dass die ersten zehn Mitarbeiter einfach so eingestellt werden können, erst ab dem elften Mitarbeiter ist das Einstellen eines Managers in HR notwendig. Wird ein neu einzustellende Mitarbeiter in Human Resources eingestellt erhöht sich entsprechend der Wert \enquote{maxNeueMitarbeiter} um neun, da ein HR-Mitarbeiter für zehn andere Mitarbeiter zuständig ist. Soll einer oder mehrere Mitarbeiter in einer anderen Abteilung als HR eingestellt werden, so ist dies nur möglich, wenn maxNeueMitarbeiter in der Kennzahlensammlung größer oder gleich der Anzahl neu einzustellender Mitarbeiter ist, maxNeueMitarbeiter wird anschließend entsprechend um diese Anzahl korrigiert. Sind nicht genügend People Manager in HR vorhanden, maxNeueMitarbeiter liegt also unter der Anzahl der vom Benutzer gewünschten neu Einzustellenden, so wird eine \enquote{ZuWenigMitarbeiterException} geworfen, die am Frontend eine entsprechende Nachricht auslöst, dass zunächst einer oder mehrere Mitarbeiter in HR angestellt werden müssen, um diese Einstellung(en) zu ermöglichen, und der Vorgang wird abgebrochen. Zur Einstellung neuer Mitarbeiter wird die open-source API \enquote{Random User Generator}\footnote{https://randomuser.me/} verwendet, die zufällige Personen generiert. Für die Zwecke des Unternehmensplanspiels wird von dieser API ein Name, Bild und Geschlecht des neuen Mitarbeiters abgefragt beziehungsweise generiert. Diese Daten werden über die URL \enquote{https://randomuser.me/api/?results=} + anzahl + \enquote{\&inc=name,picture,gender} abgefragt, durch einen BufferedReader\footnote{https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html} in Verbindung eines InputStreamReaders\footnote{https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html} eingelesen und anschließend als JsonObject\footnote{https://static.javadoc.io/com.google.code.gson/gson/2.8.0/com/google/gson/JsonObject.html} in einem JsonArray\footnote{https://static.javadoc.io/com.google.code.gson/gson/2.8.0/com/google/gson/JsonArray.html} zwischen gespeichert. Von hieraus können anschließend neue Mitarbeiter-Objekte erstellt werden und mit den entsprechenden Daten aus dem JsonArray gefüllt werden. Das Mitarbeiter-Gehalt wird der Methode übergeben und entsprechend gesetzt, da diese Entscheidung durch den Spieler fällt.

In der HR-Abteilung gibt es darüber hinaus noch die Möglichkeit seinen Mitarbeitern soziale Leistungen anzubieten. Hierfür sind zwei weitere Klassen implementiert: \enquote{SozialProjekt} und \enquote{ZeitGeld}, was eine Spezialisierung von SozialProjekt ist. Ein SozialProjekt ist beispielsweise die Inbetriebnahme einer Kantine, bei ZeitGeld handelt es sich um freiwillige Sonderzahlungen des Unternehmens wie zum Beispiel Weihnachtsgled. Diese Maßnahmen können gestartet und nach belieben wieder gestoppt werden (Methoden start() und stop()), verursachen, wenn sie aktiv sind (boolesche Variable \enquote{active}), einmalige und/oder laufende Kosten und erhöhen die Mitarbeiterzufriedenheit (siehe start(), stop() und update()). Diese Projekte werden in der Klasse HR in einer ArrayList \enquote{projekte} verwaltet.

\subsubsubsection{Produktion} \textnormal{\textsf{\small{Luca Dommes}}}}
\label{Produktion}

In der Abteilung \enquote{Produktion} findet die Leistungserstellung statt. Bevor jedoch produziert werden kann müssen einige Voraussetzungen erfüllt werden.

So ist für die Produktion sowie für die Lagerung fertiggestellter Produkte der Faktor Boden notwendig. Hierfür wurde eine neue Java-Klasse namens \enquote{Halle} implementiert. Diese Halle repräsentiert einerseits eine Produktionshalle, die eine gewisse Kapazität, also Anzahl von Stellplätzen, für Maschinen hat und andererseits eine Lagerhalle, die eine gewisse Lagerkapazität (= maximal lagerbare Produkte) hat. Eine Halle hat neben der Art (also \enquote{Produktionshalle} oder \enquote{Lagerhalle}) und der Kapazität die Attribute \enquote{groesse} und \enquote{preis}. Die Größe (\enquote{groesse}) ist ein Integer-Wert, der eins, zwei oder drei sein kann und vom Spieler gewählt wird. Abhängig von der Art der Halle Größe wird dann in der Methode \enquote{findPreisundKapazitaet()} der Preis und die Kapazität festgelegt. Erzeugt werden diese Objekte durch die Methoden \enquote{produktionshalleKaufen()} und \enquote{lagerhalleKaufen()} in der Produktions-Klasse, die ebenso die entsprechenden Bilanzposten anpassen.

Neben dem Boden sind für die Produktion ebenso Maschinen notwendig. Hierfür gibt es die Klasse \enquote{Maschine}. Das Attribut \enquote{klasse} ist vergleichbar mit der Größe der Halle, denn hiervon hängt die Höhe der Attribute \enquote{kapazitaet} (= Ausbringungsmenge pro Monat) und \enquote{anschaffungskosten} ab, diese werden gesetzt in der Methode \enquote{findKapazitaetUndAnschaffungskosten()}. Weitere Attribute sind \enquote{produkt}, da eine Maschine nur ein bestimmtes Produkt produzieren kann, \enquote{energiekosten} und \enquote{status}. Die Energiekosten sind bei allen Maschinen gleich, sodass sich hierdurch die größere Maschine lohnt. Der Status spiegelt die Abnutzung wieder, er wird also bei jedem Timer Count herunter gesetzt, gleichzeitig steigen die Energiekosten (siehe \enquote{statusUndEnergiekstRuntersetzen()}). Diesem Effekt kann durch Reparaturen entgegengewirkt werden (siehe \enquote{reparieren()}). In der Produktions-Klasse werden die Maschinen in der ArrayList \enquote{maschinen} verwaltet. Maschinen können auch wieder verkauft werden, der Wiederverkaufspreis richtet sich hier nach den halben Anschaffungskosten multipliziert mit dem Status der Maschine (siehe \enquote{maschineVerkaufen()}).

Ist die letzte Voraussetzung zur Produktion, nämlich der Faktor Arbeit erfüllt, sprich gibt es in der Abteilung Produktion Mitarbeiter, so kann produziert werden (siehe \enquote{produzieren()}), falls nicht wirft diese Methode eine entsprechende Exception. Dieser Methode gibt der Nutzer Informationen zum \enquote{Produkt} beziehungsweise der \enquote{Produktlinie} mit. Dies sind zwei weitere Java-Klassen. Ein Produkt besteht aus den Attributen \enquote{name} (etwa \enquote{Rucksack} oder \enquote{Duffel}), \enquote{qualiteatsstufe} (A, B oder C), \enquote{herstellkosten} und \enquote{forschungsbonus} (vgl. Forschung). Abhängig von dem Produkttyp und der Qualitätstufe (also zum Beispiel \enquote{Rucksack der Qualitätsstufe A}) werden die Herstellkosten für das Produkt gesetzt (siehe \enquote{findHerstellkosten()}). Die Klasse \enquote{Produktionslinie} enthält neben einem solchen Produkt-Objekt Informationen über Menge, Laufzeit, Beginn, Ende und ID (zusammengesetzt aus Produkttyp und Qualitätsstufe). Somit können Objekte der Klasse Produktlinie einerseits als Produktionsauftrag (siehe ArrayList \enquote{aufträge}), und andererseits auch als Objekt für die Lagerbestände (siehe ArrayList \enquote{lager}) verwendet werden.

In der Methode \enquote{produkteFertigstellen()}, die über Produktion.update() aufgerufen wird, wird über \enquote{aufträge} iteriert und für jedes Produktlinien-Objekt aber auch in Hinblick auf beispielsweise die Produktionskapazität eine  umfangreiche Prüfung durchgeführt, etwa ob (immer noch) genügend Maschinen, Mitarbeiter oder Lagerplatz vorhanden sind. Falls dies nicht der Fall ist wird eine entsprechende Exception geworfen, die dem Nutzer am Frontend das Problem anzeigt. Die Produkte können hierdurch nicht produziert werden beziehungsweise werden \enquote{entsorgt} wenn nicht genügend Lagerplatz vorhanden ist. Die maximale Menge der zu produzierenden Produkte richtet sich nach sowohl Mitarbeiter-, als auch der Maschinenkapazität und orientiert sich am jeweils niedrigeren Wert (siehe Verwendung der Methoden getMaxMitarbeiterProdMenge(), getMaxMaschProdMengen(), getMaxMaschProdMengeByProdukt(), getVerfuegbareMengeByProdukt). Stimmen alle Parameter so werden die fertigen Erzeugnisse in der ArrayList \enquote{lager} abgelegt und auch die entsprechenden Bilanzposten angepasst.

\subsubsubsection{Marketing} \textnormal{\textsf{\small{Jan Scheuermann}}}}
\label{Marketing}
% Jan Scheuermann

\subsubsubsection{Vertrieb} \textnormal{\textsf{\small{Jan Oehlers}}}}
\label{Vertrieb}
% Jan Oehlers

\subsubsubsection{Forschung} \textnormal{\textsf{\small{Jan Scheuermann}}}}
\label{Forschung}
% Jan Scheuermann

\subsubsubsection{Finanzen} \textnormal{\textsf{\small{Jan Scheuermann}}}}
\label{Finanzen}
% Jan Scheuermann


% Markus:
\input{source/32_rest}
\input{source/33_angularjs}